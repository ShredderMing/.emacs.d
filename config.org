#+TITLE: Emacs 配置文件
#+AUTHOR: shredderming
#+LATEX_HEADER: \usepackage{ctex}

* 前言
* 基础配置
** 包管理器（use-package）
   #+begin_src emacs-lisp
	  (eval-when-compile
	    (require 'package)
	    (setq package-enable-at-startup nil)
	    (require 'package-x)
	    (defvar local-archive
	      (expand-file-name "local/" user-emacs-directory)
	      "Location of the package archive.")
	    (setq package-archive-upload-base local-archive)
	    (setq package-archives `(("gnu" . "https://elpa.gnu.org/packages/")
				     ("melpa" . "https://melpa.org/packages/")
				     ("org" . "https://orgmode.org/elpa/")
				     ("local" . ,local-archive)))
	    (package-initialize)
	    (unless (package-installed-p 'use-package)
	      (package-refresh-contents)
	      (package-install 'use-package))
	    (require 'use-package))

   #+end_src
** Auto tangle
   保存时，自动导出配置代码并编译，由于编译速度慢，用async包优化
   #+begin_src emacs-lisp
     (use-package async
       :ensure t
       :commands (async-start))
   #+end_src
   保存时自动编译
   #+begin_src emacs-lisp
     (defun tangle-init ()
       (when (equal (buffer-file-name)
		    (expand-file-name (concat user-emacs-directory "config.org")))
	 (message "Tangling...")
	 (async-start
	  (lambda ()
	    (let ((prog-mode-hook nil)
		  (src (expand-file-name "config.org" user-emacs-directory))
		  (dest (expand-file-name "config.el" user-emacs-directory)))
	      (require 'ob-tangle)
	      (org-babel-tangle-file src dest)
	      (if (byte-compile-file dest)
		  (byte-compile-dest-file dest)
		(with-current-buffer byte-compile-log-buffer
		  (buffer-string)))))
	  (lambda (result)
	    (message "Tangling completed: %s" result)))))
     (add-hook 'after-save-hook 'tangle-init)
   #+end_src
** frame尺寸
   #+begin_src emacs-lisp
     (setq initial-frame-alist '((width . 102) (height . 54)))
     (setq default-frame-alist '((width . 100) (height . 52)))
   #+end_src
** 编码
   #+begin_src emacs-lisp
     (prefer-coding-system 'utf-8)
     (setq-default buffer-file-coding-system 'utf-8-auto-unix)
   #+end_src
** 基础设置
   #+begin_src emacs-lisp
     (setq inhibit-startup-message t
	   inhibit-startup-screen t
	   echo-keystrokes 0.1
	   initial-scratch-message nil
	   sentence-end-double-space nil)
     (fset 'yes-or-no-p 'y-or-n-p)
     (setq-default truncate-lines t)
     (dolist (mode '(tool-bar-mode
		     menu-bar-mode
		     fringe-mode
		     scroll-bar-mode
		     tooltip-mode))
       (funcall mode 0))
     (dolist (mode '(column-number-mode
		     subword-mode))
       (funcall mode 1))
   #+end_src
** 光标
   #+begin_src emacs-lisp
     (setq-default cursor-type '(bar . 1))
     (setq cursor-in-non-selected-windows t)
     (blink-cursor-mode 0)
   #+end_src
** 备份以及自动保存
   #+begin_src emacs-lisp
     (setq backup-by-copying t
	   backup-directory-alist
	   '(("." . "~/.saves"))
	   delete-old-versions t
	   kept-new-versions 6
	   kept-old-versions 2
	   version-control t)
     (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
	   create-lockfiles nil)
   #+end_src
** 大文件警告
   #+begin_src emacs-lisp
     (setq large-file-warning-threshold (* 15 1024 1024))
   #+end_src
** 远程编辑文件（tramp）
   #+begin_src emacs-lisp
     (use-package tramp
       :config
       (setq tramp-default-method "ssh"
	     tramp-backup-directory-alist backup-directory-alist))
     (use-package tramp-sh
       :config
       (setq tramp-ssh-controlmaster-options "ssh"))
   #+end_src
** 最近打开的文件
   #+begin_src emacs-lisp
     (use-package recentf
       :config
       (setq recentf-max-saved-items 1000
	     recentf-exclude '("/tmp/" "/ssh:"))
       (recentf-mode))
   #+end_src
** 文件浏览（dired）
   #+begin_src emacs-lisp
     (use-package dired
       :bind (:map dired-mode-map
		   ("C-c C-e" . wdired-change-to-wdired-mode))
       :init
       (setq dired-dwim-target t
	     dired-recursive-copies 'top
	     dired-recursive-deletes 'top
	     dired-listing-switches "-alh")
       :config
       (add-hook 'dired-mode-hook 'dired-hide-details-mode))
   #+end_src
** 内置浏览器（eww）
   #+begin_src emacs-lisp
     (use-package eww
       :bind* (("M-m g x" . eww)
	       ("M-m g :" . eww-browse-with-external-browser)
	       ("M-m g #" . eww-list-histories)
	       ("M-m g {" . eww-back-url)
	       ("M-m g }" . eww-forward-url))
       :config
       (add-hook 'eww-mode-hook 'visual-line-mode))
   #+end_src
** Info
   #+begin_src emacs-lisp
     (use-package info
       :bind* (("M-m g (" . Info-prev)
	       ("M-m g )" . Info-next)
	       ("M-m ^" . Info-up)
	       ("M-m &" . Info-goto-node)))
   #+end_src
** doc
   #+begin_src emacs-lisp
     (use-package doc-view
       :commands (doc-view-next-page doc-view-previous-page)
       :config
       (setq doc-view-continuous t))
   #+end_src
** winner-mode
   #+begin_src emacs-lisp
     (use-package winner
       :commands (winner-undo winner-redo)
       :config
       (winner-mode 1))
   #+end_src
** 按键绑定
   #+begin_src emacs-lisp
     (bind-keys*
       ("C-r"       . dabbrev-expand)
       ("M-/"       . hippie-expand)
       ("C-S-d"     . kill-whole-line)
       ("M-m SPC c" . load-theme)
       ("M-m SPC R" . locate)
       ("M-m W"     . winner-undo)
       ("M-m g m"   . make-frame)
       ("M-m g M"   . delete-frame)
       ("M-m g n"   . select-frame-by-name)
       ("M-m g N"   . set-frame-name)
       ("M-m B"     . mode-line-other-buffer)
       ("M-m ="     . indent-region)
       ("M-m g f"   . find-file-at-point)
       ("M-m g u"   . downcase-region)
       ("M-m g U"   . upcase-region)
       ("M-m g C"   . capitalize-region)
       ("M-m g F"   . follow-mode)
       ("M-m R"     . overwrite-mode)
       ("M-m g j"   . doc-view-next-page)
       ("M-m g k"   . doc-view-previous-page)
       ("M-m : t"   . emacs-init-time)
       ("M-m g q"   . fill-paragraph)
       ("M-m g @"   . compose-mail)
       ("M-m SPC ?" . describe-bindings))
   #+end_src
* 扩展配置
** 环境变量
   #+begin_src emacs-lisp
     (use-package exec-path-from-shell
       :ensure t
       :demand t
       :commands (exec-path-from-shell-initialize)
       :init
       (setq exec-path-from-shell-check-startup-files nil)
       :config
       (when (memq window-system '(mac ns x))
	 (exec-path-from-shell-initialize)))
   #+end_src
** 快捷键提示（which key）
   #+begin_src emacs-lisp
     (use-package which-key
       :ensure t
       :defer t
       :commands (which-key-mode which-key-add-key-based-replacements)
       :init
       (setq which-key-sort-order 'which-key-key-order-alpha)
       :bind* (("M-m ?" . which-key-show-top-level))
       :config
       (which-key-mode)
       (which-key-add-key-based-replacements
	"M-m ?" "top level bindings"))
   #+end_src
** 词典
   #+begin_src emacs-lisp
     (use-package youdao-dictionary
       :ensure t
       :bind (("C-c y" . youdao-dictionary-search-at-point))
       :config
       (setq url-automatic-caching t))
   #+end_src
** 重启emacs
   #+begin_src emacs-lisp
     (use-package restart-emacs
       :ensure t
       :bind* (("C-x M-c" . restart-emacs)))
   #+end_src

** 全屏切换
   #+begin_src emacs-lisp
     
   #+end_src
* Modal editing
** 初始化
   #+begin_src emacs-lisp
     (use-package modalka
       :ensure t
       :demand t
       :commands (modalka-global-mode modalka-define-kbd)
       :bind* (("C-z" . modalka-mode))
       :diminish (modalka-mode . "μ")
       :init
       (setq modalka-cursor-type 'box)
       :config
       (global-set-key (kbd "<escape>") #'modalka-mode)
       (modalka-global-mode 1)
       (add-to-list 'modalka-excluded-modes 'magit-status-mode)
       (add-to-list 'modalka-excluded-modes 'magit-popup-mode)
       (add-to-list 'modalka-excluded-modes 'eshell-mode)
       (add-to-list 'modalka-excluded-modes 'deft-mode)
       (add-to-list 'modalka-excluded-modes 'term-mode)
       (which-key-add-key-based-replacements
	"M-m"     "Modalka prefix"
	"M-m :"   "extended prefix"
	"M-m m"   "move prefix"
	"M-m s"   "send code prefix"
	"M-m SPC" "user prefix"
	"M-m g"   "global prefix"
	"M-m o"   "org prefix"
	"M-m a"   "expand around prefix"
	"M-m i"   "expand inside prefix"
	"M-m ["   "prev nav prefix"
	"M-m ]"   "next nav prefix"))
   #+end_src
** 按键绑定
*** Numbers
    #+begin_src emacs-lisp
      (modalka-define-kbd "0" "C-0")
      (modalka-define-kbd "1" "C-1")
      (modalka-define-kbd "2" "C-2")
      (modalka-define-kbd "3" "C-3")
      (modalka-define-kbd "4" "C-4")
      (modalka-define-kbd "5" "C-5")
      (modalka-define-kbd "6" "C-6")
      (modalka-define-kbd "7" "C-7")
      (modalka-define-kbd "8" "C-8")
      (modalka-define-kbd "9" "C-9")
    #+end_src
*** Movement and one key presses
    #+begin_src emacs-lisp
      (modalka-define-kbd "h" "C-b")
      (modalka-define-kbd "j" "C-n")
      (modalka-define-kbd "k" "C-p")
      (modalka-define-kbd "l" "C-f")
      (modalka-define-kbd "e" "M-f")
      (modalka-define-kbd "b" "M-b")
      (modalka-define-kbd "n" "M-n")
      (modalka-define-kbd "N" "M-p")
      (modalka-define-kbd "{" "M-{")
      (modalka-define-kbd "}" "M-}")
      (modalka-define-kbd "0" "C-a")
      (modalka-define-kbd "$" "C-e")
      (modalka-define-kbd "G" "M->")
      (modalka-define-kbd "y" "M-w")
      (modalka-define-kbd "p" "C-y")
      (modalka-define-kbd "P" "M-y")
      (modalka-define-kbd "x" "C-d")
      (modalka-define-kbd "D" "C-k")
      (modalka-define-kbd "z" "C-l")
      (modalka-define-kbd "!" "M-&")
      (modalka-define-kbd "J" "C-v")
      (modalka-define-kbd "K" "M-v")
      (modalka-define-kbd "M" "C-u")
      (modalka-define-kbd "(" "M-a")
      (modalka-define-kbd ")" "M-e")
      (modalka-define-kbd "/" "C-s")
      (modalka-define-kbd "E" "C-g")
      (modalka-define-kbd "d" "C-w")
      (modalka-define-kbd "w" "C-x o")
      (modalka-define-kbd "W" "M-m W")
      (modalka-define-kbd "B" "M-m B")
      (modalka-define-kbd "H" "C-x >")
      (modalka-define-kbd "L" "C-x <")
      (modalka-define-kbd "Z" "C-x 1")
      (modalka-define-kbd "q" "C-x (")
      (modalka-define-kbd "Q" "C-x )")
      (modalka-define-kbd "." "M-m .")
      (modalka-define-kbd "?" "M-m ?")
      (modalka-define-kbd "v" "C-SPC")
      (modalka-define-kbd "V" "M-m V")
      (modalka-define-kbd "=" "M-m =")
      (modalka-define-kbd "R" "M-m R")
      (modalka-define-kbd "X" "C-x C-x")
      (modalka-define-kbd "+" "C-x r m")
      (modalka-define-kbd "'" "C-x r b")
      (modalka-define-kbd "\\" "C-c C-c")
    #+end_src
*** Global prefixed keys
    #+begin_src emacs-lisp
      (modalka-define-kbd "g g" "M-<")
      (modalka-define-kbd "g o" "C-x C-e")
      (modalka-define-kbd "g O" "C-M-x")
      (modalka-define-kbd "g m" "M-m g m")
      (modalka-define-kbd "g M" "M-m g M")
      (modalka-define-kbd "g n" "M-m g n")
      (modalka-define-kbd "g N" "M-m g N")
      (modalka-define-kbd "g f" "M-m g f")
      (modalka-define-kbd "g F" "M-m g F")
      (modalka-define-kbd "g j" "M-m g j")
      (modalka-define-kbd "g k" "M-m g k")
      (modalka-define-kbd "g q" "M-m g q")
      (modalka-define-kbd "g w" "C-x 3")
      (modalka-define-kbd "g W" "C-x 2")
      (modalka-define-kbd "g @" "M-m g @")
      (modalka-define-kbd "g ;" "M-m g ;")
      (modalka-define-kbd "g :" "M-m g :")
      (modalka-define-kbd "g #" "M-m g #")
      (modalka-define-kbd "g {" "M-m g {")
      (modalka-define-kbd "g }" "M-m g }")
      (modalka-define-kbd "g (" "M-m g (")
      (modalka-define-kbd "g )" "M-m g )")
      (modalka-define-kbd "^" "M-m ^")
      (modalka-define-kbd "&" "M-m &")
      (modalka-define-kbd "g S" "C-j")
      (modalka-define-kbd "g ?" "C-h k")
    #+end_src
*** Select region prefixed keys
    #+begin_src emacs-lisp
      (modalka-define-kbd "i a" "C-x h")
    #+end_src
*** Forward navigation prefixed keys
    #+begin_src emacs-lisp
      (modalka-define-kbd "] ]" "C-x n n")
      (modalka-define-kbd "] s" "M-m ] s")
    #+end_src
*** Backward navigation prefixed keys
    #+begin_src emacs-lisp
      (modalka-define-kbd "[ [" "C-x n w")
    #+end_src
*** Extended prefix to quit/restart and time
    #+begin_src emacs-lisp
      (modalka-define-kbd ": q" "C-x C-c")
      (modalka-define-kbd ": r" "C-x M-c")
      (modalka-define-kbd ": t" "M-m : t")
    #+end_src
*** User prefix for common functions
    #+begin_src emacs-lisp
      (modalka-define-kbd "g U" "C-c C-k")
      (modalka-define-kbd "SPC j" "M-x")
      (modalka-define-kbd "SPC a" "C-x b")
      (modalka-define-kbd "SPC k" "C-x k")
      (modalka-define-kbd "SPC g" "M-g g")
      (modalka-define-kbd "SPC d" "C-x d")
      (modalka-define-kbd "SPC q" "C-x 0")
      (modalka-define-kbd "SPC f" "C-x C-f")
      (modalka-define-kbd "SPC w" "C-x C-s")
      (modalka-define-kbd "SPC c" "M-m SPC c")
      (modalka-define-kbd "SPC R" "M-m SPC R")
      (modalka-define-kbd "SPC ?" "M-m SPC ?")
    #+end_src
** which-key
*** Number
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
	"0" "0"
	"1" "1"
	"2" "2"
	"3" "3"
	"4" "4"
	"5" "5"
	"6" "6"
	"7" "7"
	"8" "8"
	"9" "9")
    #+end_src
*** Movement and one key presses
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
	"ESC" "toggle mode"
	"DEL" "smart del"
	"TAB" "smart tab"
	"RET" "smart enter"
	"h"   "prev char"
	"j"   "next line"
	"k"   "prev line"
	"l"   "next char"
	"e"   "next word"
	"b"   "prev word"
	"n"   "next history item"
	"N"   "prev history item"
	"{"   "next para"
	"}"   "prev para"
	"0"   "start of line"
	"$"   "end of line"
	"("   "start of sentence"
	")"   "end of sentence"
	"/" "search"
	"E"   "exit anything"
	"B"   "previous buffer"
	"W"   "winner undo"
	"w"   "other window"
	"G"   "end of file"
	"d"   "delete selection"
	"y"   "copy selection"
	"p"   "paste"
	"P"   "paste history"
	"x"   "delete char"
	"D"   "delete rest of line"
	"M"   "modify argument"
	"z"   "scroll center/top/bot"
	"Z"   "zoom into window"
	"H"   "scroll left"
	"J"   "scroll down"
	"K"   "scroll up"
	"L"   "scroll right"
	"'"   "org edit separately"
	"q"   "start macro"
	"Q"   "end macro"
	"?"   "top level bindings"
	"v"   "start selection"
	"R"   "overwrite mode"
	"X"   "exchange point and mark"
	"+"   "set bookmark"
	"'"   "jump to bookmark"
	"="   "indent region"
	"\\"  "C-c C-c"
	"!"   "async shell command"
	"&"   "shell command")

    #+end_src
*** Global prefixed keys
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
	"g"   "global prefix"
	"g g" "start of file"
	"g m" "make frame"
	"g M" "delete frame"
	"g n" "select frame by name"
	"g N" "name frame"
	"g j" "next pdf page"
	"g k" "previous pdf page"
	"g f" "file/url at cursor"
	"g F" "enable follow mode"
	"g o" "eval elisp"
	"g O" "eval defun"
	"g w" "vertical split win"
	"g W" "horizontal split win"
	"g S" "split line"
	"g @" "compose mail"
	"g #" "list eww histories"
	"g x" "browse with eww"
	"g :" "browse with external browser"
	"g {" "eww back"
	"g }" "eww forward"
	"g (" "info previous"
	"g )" "info next"
	"^"   "info up"
	"&"   "info goto"
	"g q" "format para"
	"g ?" "find command bound to key")
    #+end_src
*** Select region prefixed keys
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
       "i" "expand prefix"
       "i a" "expand entire buffer")
    #+end_src
*** Forward navigation prefixed keys
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
	"]"   "forward nav/edit"
	"] ]" "narrow region"
	"] s" "next spell error")
    #+end_src
*** Backward navigation prefixed keys
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
	"["   "backward nav/edit"
	"[ [" "widen region")
    #+end_src
*** Extended prefix to quit/restart and time
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
	":"   "extended prefix"
	": q" "quit emacs"
	": r" "restart emacs"
	": t" "initiliazation time")
    #+end_src
*** User prefix for common functions
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
	"SPC"   "custom prefix"
	"SPC ?" "describe bindings"
	"SPC j" "jump to cmd"
	"SPC f" "find file"
	"SPC a" "switch buffers"
	"SPC g" "goto line"
	"SPC d" "dired"
	"SPC k" "close buffer"
	"SPC w" "save buffer"
	"SPC c" "load theme"
	"SPC R" "locate"
	"SPC q" "quit window"
	"g U"   "simulate C-c C-k")
    #+end_src
** Hydras
   #+begin_src emacs-lisp
	  (use-package hydra
	    :ensure t
	    :commands (hydra-default-pre
		       hydra-keyboard-quit
		       hydra--call-interactively-remap-maybe
		       hydra-show-hint
		       hydra-set-transient-map))
   #+end_src
* 导航相关（Navigating）
** Undo tree
   #+begin_src emacs-lisp
     (use-package undo-tree
       :ensure t
       :commands (global-undo-tree-mode)
       :bind* (("M-m u" . undo-tree-undo)
	       ("M-m r" . undo-tree-redo)
	       ("M-m U" . undo-tree-visualize))
       :config
       (global-undo-tree-mode 1))
   #+end_src
   - Modal binding
    #+begin_src emacs-lisp
      (modalka-define-kbd "u" "M-m u")
      (modalka-define-kbd "U" "M-m U")
      (modalka-define-kbd "r" "M-m r")
    #+end_src
   - Which key
    #+begin_src emacs-lisp
      (which-key-add-key-based-replacements
       "u" "undo"
       "r" "redo"
       "U" "undo tree")
    #+end_src
** 导航到最后修改位置
   #+begin_src emacs-lisp
     (use-package goto-chg
       :ensure t
       :bind* (("M-m g ;" . goto-last-change)
	       ("M-m g ," . goto-last-change-reverse)))
   #+end_src 
   - Modal binding
     #+begin_src emacs-lisp
       (modalka-define-kbd "g ;" "M-m g ;")
       (modalka-define-kbd "g ," "M-m g ,")
     #+end_src
   - Whick key
     #+begin_src emacs-lisp
       (which-key-add-key-based-replacements
	"g ;" "goto last change"
	"g ," "goto last change reverse")
     #+end_src
** Avy
   #+begin_src emacs-lisp
     (use-package avy
       :ensure t
       :init
       (setq avy-keys-alist
	     `((avy-goto-char-timer . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))
	       (avy-goto-line . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))))
       (setq avy-style 'pre)
       :bind* (("M-m f" . avy-goto-char-timer)
	       ("M-m F" . avy-goto-line)))
   #+end_src
   - Modal binding
     #+begin_src emacs-lisp
       (modalka-define-kbd "f" "M-m f")
       (modalka-define-kbd "F" "M-m F")
     #+end_src
   - Which key
     #+begin_src emacs-lisp
       (which-key-add-key-based-replacements
	"f" "find on-screen"
	"F" "find line")
     #+end_src

** Highlight symbol
   #+begin_src emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :commands (highlight-symbol-next highlight-symbol-prev highlight-symbol-nav-mode)
       :bind (("M-n" . highlight-symbol-next)
	      ("M-p" . highlight-symbol-prev))
       :config
       (highlight-symbol-nav-mode))
   #+end_src

** Projectile
   #+begin_src emacs-lisp
     (use-package projectile
       :ensure t
       :init
       (setq projectile-file-exists-remote-cache-expire (* 10 60))
       :commands (projectile-find-file
		  projectile-switch-project
		  projectile-find-other-file
		  projectile-mode)
       :bind* (("M-m SPC d" . projectile-find-file)
	       ("M-m SPC D" . projectile-switch-project)
	       ("M-m SPC TAB" . projectile-find-other-file))
       :diminish projectile-mode
       :config
       (projectile-mode))
   #+end_src
   - Modal binding
     #+begin_src emacs-lisp
       (modalka-define-kbd "SPC d" "M-m SPC d")
       (modalka-define-kbd "SPC D" "M-m SPC D")
       (modalka-define-kbd "SPC TAB" "M-m SPC TAB")
     #+end_src
    - which key
      #+begin_src emacs-lisp
	(which-key-add-key-based-replacements
	  "SPC d" "project files"
	  "SPC D" "project switch"
	  "SPC TAB" "alternate file")
      #+end_src
** Ztree
   #+begin_src emacs-lisp
     (use-package ztree
       :ensure t
       :commands (ztree-dir ztree-diff)
       :bind* (("M-m g v" . ztree-dir)
	       ("M-m g V" . ztree-diff))
       :init
       (setq ztree-dir-move-focus t))
   #+end_src
** Neotree
   #+begin_src emacs-lisp
     (use-package neotree
       :ensure t
       :commands (neotree-toggle)
       :bind* (("M-m SPC n" . neotree-toggle))
       :init
       (setq neo-smart-open t))
   #+end_src
   - Modal binding
     #+begin_src emacs-lisp
       (modalka-define-kbd "SPC n" "M-m SPC n")
     #+end_src
   - which key
     #+begin_src emacs-lisp
       (which-key-add-key-based-replacements
	 "SPC n" "directory tree")
     #+end_src
** Tags based navigation
   #+begin_src emacs-lisp
     (use-package ggtags
       :ensure t
       :diminish ggtags-mode
       :commands (ggtags-build-imenu-index)
       :bind* (("M-m T" . ggtags-find-tag-regexp)
	       ("M-m g t" . ggtags-create-tags)
	       ("M-m g T" . ggtags-update-tags))
       :init
       (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
       :config
       (add-hook 'prog-mode-hook 'ggtags-mode))
   #+end_src
   - Modal binding
     #+begin_src emacs-lisp
       (modalka-define-kbd "T" "M-m T")
       (modalka-define-kbd "g t" "M-m g t")
       (modalka-define-kbd "g T" "M-m g T")
     #+end_src
   - which key
     #+begin_src emacs-lisp
       (which-key-add-key-based-replacements
	 "g t" "create tags"
	 "g T" "update tags"
	 "T" "global tags search")
     #+end_src
** Dumb jump
   #+begin_src emacs-lisp
     (use-package dumb-jump
       :ensure t
       :commands (dumb-jump-mode)
       :bind (("C-c S" . dumb-jump-go))
       :config
       (dumb-jump-mode))

     (modalka-define-kbd "S" "C-c S")

     (which-key-add-key-based-replacements
       "S" "src at point")
   #+end_src
** Perspective
   #+begin_src emacs-lisp
     (use-package perspective
       :ensure t
       :commands (persp-mode)
       :bind* (("M-m SPC p" . persp-switch)
	       ("M-m SPC P" . persp-kill)
	       ("M-m SPC A" . persp-switch-to-buffer)
	       ("M-m g r" . persp-rename))
       :config
       (persp-mode 1))
   #+end_src
   - Modal binding
     #+begin_src emacs-lisp
       (modalka-define-kbd "SPC p" "M-m SPC p")
       (modalka-define-kbd "SPC P" "M-m SPC P")
       (modalka-define-kbd "SPC A" "M-m SPC A")
       (modalka-define-kbd "g r" "M-m g r")
     #+end_src
   - which key
     #+begin_src emacs-lisp
       (which-key-add-key-based-replacements
	 "SPC p" "perspective switch"
	 "SPC P" "perspective kill"
	 "SPC A" "perspective buffer switch"
	 "g r" "perspective rename")
     #+end_src
** Toggle zoom
   #+begin_src emacs-lisp
     (use-package zoom-window
       :ensure t
       :bind* (("M-m Z" . zoom-window-zoom)))

     (modalka-define-kbd "Z" "M-m Z")

     (which-key-add-key-based-replacements
       "Z" "zoom window")
   #+end_src
** Code documentation
   #+begin_src emacs-lisp
     (use-package dash-at-point
       :ensure t
       :bind (("C-c I" . dash-at-point))
       :bind* (("M-m SPC i" . dash-at-point-with-docset)
	       ("M-m SPC I" . dash-at-point)))

     (modalka-define-kbd "SPC i" "M-m SPC i")
     (modalka-define-kbd "SPC I" "M-m SPC I")
     (modalka-define-kbd "I" "C-c I")

     (which-key-add-key-based-replacements
       "I" "info at point"
       "SPC i" "documentation prompt"
       "SPC I" "documentation at point")
   #+end_src
** Hydras
*** 窗口导航
    #+begin_src emacs-lisp
      (defhydra st/hydra-of-windows (:color red
				     :hint nil)
	"
       ^Move^    ^Size^    ^Change^                    ^Split^           ^Text^
       ^^^^^^^^^^^------------------------------------------------------------------
       ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   _u_: winner-undo _o_: rotate  _v_: vertical     _+_: zoom in
       _h_ ^+^ _l_   _H_ ^+^ _L_   _r_: winner-redo            _s_: horizontal   _-_: zoom out
       ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   _c_: close                  _z_: zoom         _q_: quit
      "
	("h" windmove-left)
	("j" windmove-down)
	("k" windmove-up)
	("l" windmove-right)
	("H" shrink-window-horizontally)
	("K" shrink-window)
	("J" enlarge-window)
	("L" enlarge-window-horizontally)
	("v" utils/split-right-and-move)
	("s" utils/split-below-and-move)
	("c" delete-window)
	("f" toggle-frame-fullscreen :color blue)
	("o" utils/rotate-windows)
	("z" delete-other-windows)
	("u" (progn
	       (winner-undo)
	       (setq this-command 'winner-undo)))
	("r" winner-redo)
	("+" text-scale-increase)
	("-" text-scale-decrease)
	("q" nil :color blue))

      (bind-keys*
       ("M-m SPC u" . st/hydra-of-windows/body))

      (modalka-define-kbd "SPC u" "M-m SPC u")

      (which-key-add-key-based-replacements
	"SPC u" "window menu")
    #+end_src
*** 书签导航
    #+begin_src emacs-lisp
      (defhydra st/hydra-bookmarks (:color blue
				    :hint nil)
	"
       _s_: set  _b_: bookmark   _j_: jump   _d_: delete   _q_: quit
	"
	("s" bookmark-set)
	("b" bookmark-save)
	("j" bookmark-jump)
	("d" bookmark-delete)
	("q" nil :color blue))

      (bind-keys*
       ("M-m `" . st/hydra-bookmarks/body))

      (modalka-define-kbd "`" "M-m `")

      (which-key-add-key-based-replacements
	"`" "bookmark menu")
    #+end_src
* 主题（Theme）
** 字体设置
   #+begin_src emacs-lisp
     ;; 默认字体
     (when (member "Hack" (font-family-list))
       (set-face-attribute 'default nil :font "Hack" :height 120))
     ;; unicode字符
     (when (member "Symbola" (font-family-list))
       (set-fontset-font t 'unicode "Symbola" nil 'prepend))
     (when (member "Noto Sans CJK SC" (font-family-list))
       (set-fontset-font t 'han (font-spec :family "Noto Sans CJK SC")))
   #+end_src
* Org相关
** 基础设置
   #+begin_src emacs-lisp
     (use-package org
       :pin org
       :ensure org-plus-contrib
       :init
       (setq org-directory "~/Notes"
	     org-hide-emphasis-markers t
	     org-image-actual-width '(300)
	     org-src-fontify-natively t
	     org-src-tab-acts-natively t
	     org-export-backends '(beamer html latex md)))

     (use-package ox
       :pin org
       :ensure org-plus-contrib
       :init
       (setq org-export-with-smart-quotes t))
   #+end_src
** org-bullets
   #+begin_src emacs-lisp
     (use-package org-bullets
       :ensure t
       :hook (org-mode . org-bullets-mode))
   #+end_src
** 模板定义
   #+begin_src emacs-lisp
     (use-package org-tempo
       :pin org
       :ensure org-plus-contrib
       :init
       (setq org-structure-template-alist '(("s" . "src")
					    ("el" . "src emacs-lisp")
					    ("js" . "src javascript")
					    ("py" . "src python"))
	     org-tempo-keywords-alist '(("a" . "AUTHOR")
					("t" . "TITLE"))))

   #+end_src
** 任务管理
   #+begin_src emacs-lisp
     (setq org-todo-keywords
	   '((sequence "TODO(t)" "IN-PROGRESS(i)" "|" "DONE(d!)")
	     (sequence "WAITING(w@/!)" "|" "CANCELED(c@)")))
   #+end_src
** Agenda
   #+begin_src emacs-lisp
     (setq org-agenda-files '("~/Notes/Brain"))
     (setq org-deadline-warnings-days 7
	   org-agenda-span 'fortnight
	   org-agenda-skip-scheduled-if-deadline-is-shown t)
   #+end_src
** Capture
   #+begin_src emacs-lisp
     (defvar org-agenda-file-inbox "~/Notes/Brain/Inbox.org")
     (setq org-directory "~/Notes/Brain"
	   org-default-notes-file "~/Notes/Brain/Inbox.org")
     (setq org-capture-templates
	   '(("t" "todo" entry (file org-agenda-file-inbox)
	      "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
	     ("n" "note" entry (file org-agenda-file-inbox)
	      "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)))
     (setq org-refile-targets '((nil :maxlevel . 9)
				(org-agenda-files :maxlevel . 9))
	   org-refile-use-outline-path t
	   org-outline-path-complete-in-steps nil
	   org-refile-allow-creating-parent-nodes 'confirm
	   org-indirect-buffer-display 'current-window)
   #+end_src
** 按键绑定
   #+begin_src emacs-lisp
     (bind-keys*
      ("M-m o a"   . org-agenda)
      ("M-m o c"   . org-capture)
      ("M-m o i"   . org-insert-link)
      ("M-m o s"   . org-store-link)
      ("M-m o S"   . org-list-make-subtree)
      ("M-m o A"   . org-archive-subtree)
      ("M-m o g"   . org-goto)
      ("M-m o l"   . org-toggle-latex-fragment)
      ("M-m o L"   . org-toggle-link-display)
      ("M-m o I"   . org-toggle-inline-images)
      ("M-m o k"   . org-cut-subtree)
      ("M-m o V"   . org-reveal)
      ("M-m o R"   . org-refile)
      ("M-m o y"   . org-copy-subtree)
      ("M-m o h"   . org-toggle-heading)
      ("M-m o H"   . org-insert-heading-respect-content)
      ("M-m o e"   . org-export-dispatch)
      ("M-m o u"   . org-update-dblock)
      ("M-m o U"   . org-update-all-dblocks)
      ("M-m o O"   . org-footnote)
      ("M-m o ]"   . org-narrow-to-subtree)
      ("M-m o ["   . widen)
      ("M-m o N"   . org-add-note)
      ("M-m o E"   . org-set-effort)
      ("M-m o B"   . org-table-blank-field)
      ("M-m o <"   . org-date-from-calendar)
      ("M-m o >"   . org-goto-calendar)
      ("M-m o d"   . org-todo)
      ("M-m o t"   . org-set-tags-command)
      ("M-m o w"   . org-edit-special)
      ("M-m o q"   . org-edit-src-exit)
      ("M-m o z"   . clone-indirect-buffer-other-window)
      ("M-m a s"   . org-mark-subtree)
      ("M-m o RET" . org-open-at-point))
   #+end_src
* 开发相关
* 工具函数
** 打开 *config.org* 文件
   #+begin_src emacs-lisp
     (defun utils/open-config ()
       "打开emacs配置文件config.org"
       (interactive)
       (find-file (concat user-emacs-directory "config.org")))

     (bind-keys*
      ("M-m SPC v" . utils/open-config))

     (modalka-define-kbd "SPC v" "M-m SPC v")

     (which-key-add-key-based-replacements
       "SPC v" "view configuration file")
   #+end_src
** 创建新窗口并focus
   #+begin_src emacs-lisp
     (defun utils/split-below-and-move ()
       (interactive)
       (split-window-below)
       (other-window 1))

     (defun utils/split-right-and-move ()
       (interactive)
       (split-window-right)
       (other-window 1))

     (bind-keys
      ("C-x 2" . utils/split-below-and-move)
      ("C-x 3" . utils/split-right-and-move))
   #+end_src
** 两个窗口时滚动隔壁窗口中的pdf文件
   #+begin_src emacs-lisp
     (defun utils/other-pdf-next ()
       "Turns the next page in adjoining PDF file"
       (interactive)
       (other-window 1)
       (doc-view-next-page)
       (other-window 1))
     (defun utils/other-pdf-previous ()
       "Turns the previous page in adjoining PDF file"
       (interactive)
       (other-window 1)
       (doc-view-previous-page)
       (other-window 1))

     (bind-keys*
       ("M-m ] d" . utils/other-pdf-next)
       ("M-m [ d" . utils/other-pdf-previous))

     (modalka-define-kbd "] d" "M-m ] d")
     (modalka-define-kbd "[ d" "M-m [ d")

     (which-key-add-key-based-replacements
       "] d" "adjacent pdf next page"
       "[ d" "adjacent pdf prev page")
   #+end_src
** 两个窗口时滚动隔壁的窗口
   #+begin_src emacs-lisp
     (defun utils/other-window-down ()
       "Scrolls down in adjoining window"
       (interactive)
       (other-window 1)
       (scroll-up-command)
       (other-window 1))
     (defun utils/other-window-up ()
       "Scrolls up in adjoining window"
       (interactive)
       (other-window 1)
       (scroll-down-command)
       (other-window 1))

     (bind-keys*
       ("M-m g ]" . utils/other-window-down)
       ("M-m g [" . utils/other-window-up))

     (modalka-define-kbd "g ]" "M-m g ]")
     (modalka-define-kbd "g [" "M-m g [")

     (which-key-add-key-based-replacements
       "g ]" "adjacent window next page"
       "g [" "adjacent window prev page")
   #+end_src
** smater start of line
   #+begin_src emacs-lisp
     (defun utils/smarter-move-beginning-of-line (arg)
       "Move point back to indentation of beginning of line.
     Move point to the first non-whitespace character on this line.
     If point is already there, move to the beginning of the line.
     Effectively toggle between the first non-whitespace character and
     the beginning of the line.
     If ARG is not nil or 1, move forward ARG - 1 lines first.  If
     point reaches the beginning or end of the buffer, stop there."
       (interactive "^p")
       (setq arg (or arg 1))
       ;; Move lines first
       (when (/= arg 1)
	 (let ((line-move-visual nil))
	   (forward-line (1- arg))))
       (let ((orig-point (point)))
	 (back-to-indentation)
	 (when (= orig-point (point))
	   (move-beginning-of-line 1))))

     (global-set-key [remap move-beginning-of-line]
		     'utils/smarter-move-beginning-of-line)
   #+end_src
** rotate windows
   #+begin_src emacs-lisp
     (defun utils/rotate-windows ()
       "Rotate your windows"
       (interactive)
       (cond ((not (> (count-windows) 1))
	      (message "You can't rotate a single window!"))
	     (t
	      (let ((i 1)
		    (numWindows (count-windows)))
		(while (< i numWindows)
		  (let* ((w1 (elt (window-list) i))
			 (w2 (elt (window-list) (+ (% i numWindows) 1)))
			 (b1 (window-buffer w1))
			 (b2 (window-buffer w2))
			 (s1 (window-start w1))
			 (s2 (window-start w2)))
		    (set-window-buffer w1 b2)
		    (set-window-buffer w2 b1)
		    (set-window-start w1 s2)
		    (set-window-start w2 s1)
		    (setq i (1+ i))))))))
   #+end_src
* 参考的配置（不完全）
